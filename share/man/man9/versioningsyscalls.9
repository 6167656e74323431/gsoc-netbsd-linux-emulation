.\"	$NetBSD$
.\"
.\" TODO Copyright notice
.Dd June 19, 2023
.Dt versioningsyscalls 9
.Os
.Sh NAME
.Nm versioningsyscalls
.Nd guide on versioning syscalls
.Sh DESCRIPTION
.Nx
has the ability to change the ABI of a syscall whilst retaining backwards
compatibility with existing code.
This means that existing code keeps working the same way as before, and
new code can use new features and/or functionality.
In the past this has allowed
.Ft dev_t
to move from 16 bits to 32 bits,
.Ft ino_t
and
.Ft time_t
to move from 16 bits to 32 bits and
adding fields to
.Ft struct kevent
without disturbing existing binaries.
To achieve this both kernel and userland changes are required.
.Pp
In the kernel, a new syscall is added with a new ABI, and the old syscall
is retained and moved to a new location that holds the compatibility syscalls
.Pa ( src/sys/compat ) .
Kernels can be compiled with or without backwards compatibility syscalls.
See the
.Dv COMPAT_XX
options in
.Xr options 4 .
.Pp
In userland, the original syscall stub is moved into
.Pa src/lib/libc/compat
retaining the same symbol name and ABI.
The new stub is added to libc, and in the header file the syscall symbol is
made to point to the new name with the new ABI.
.Pp
This is done via symbol renaming instead of ELF versioned symbols for
historical reasons. 
.Nx
has retained binary compatibility with most syscalls since
.Nx 0.9 
with the exception of Scheduler Activation syscalls which are not being
emulated because of the cost and safety of doing so.
.Pp
To avoid confusion, the following words are used to disambiguate which version
of the system call is being described.
.Bl -tag -offset indent -width "current"
.It old
Any previous versions of the syscall, which have already been versioned and
superseded by the current version of the syscall.
.It current
The version of the syscall currently in use.
.It next
The version of the syscall that will become standard in the next release.
.El
.Pp
Additionally, 
.Em XYZ
always represents the last NetBSD release where the current
version of the system call is the default, multiplied by ten.
.Sh VERSIONING THE SYSCALL
This section describes what needs to be modified to add the new version of the
syscall.
.Ss Versioning structs
If a field in the struct
.Li my_struct
needs to be change, a copy of
.Li my_struct
first needs to be renamed to
.Li my_structXYZ
and placed in an equivalent header in
.Pa sys/compat/sys .
The original struct can then be modified as desired.
.Ss Versioning the entry point
If the original name of the syscall was
.Li my_syscall
then the new name will be
.Li __my_syscallXYZ ,
so the new entry point is
.Fn sys___my_syscallXYZ .
.Ss Modifying syscalls.conf
Make sure
.Pa sys/kern/syscalls.conf
contains
.Li compat_XYZ
in the
.Li compatopts
field.
.Ss Modifying syscalls.master
First, add the next syscall to
.Pa sys/kern/syscalls.master
and make the name the same as name as the current system call, but set the
optional compat field of the declaration to XYZ.
.Pp
Next, modify the current version of the syscall, and replace the type field with
.Li COMPAT_XYZ MODULAR compat_XYZ .
.Pp
Finally, if applicable, replace the types of the current and old versions of the
syscall with the compat type.
.Bd -literal
- 123 STD		    { int|sys||my_syscall(struct my_struct *ms); }
+ 123 COMPAT_XYZ compat_XYZ { int|sys||my_syscall(struct my_structXYZ *ms); }
\&.\&.\&.
+ 456 STD     		    { int|sys|XYZ|my_syscall(struct my_struct *ms); }
.Ed
.Ss Modifying Makefile.rump
If the current syscall is rump, make sure
.Pa sys/rump/Makefile.rump
contains
.Li XYZ
in the
.Li RUMP_NBCOMPAT
variable.
.Ss Regenerating the system calls
If versioning structs, then you will need to edit
.Pa sys/kern/makesyscalls.sh
to add the compat type to
.Li uncompattypes .
.Pp
Then regenerate the syscall tables in the usual way, first by running
.Pa sys/kern/makesyscalls.sh ,
then if the system call is rump, doing a build in
.Pa sys/rump
and then running
.Pa sys/rump/makerumpsyscalls.sh
passing it the path to the result of the build you just did as its first
argument.
.Sh KERNEL COMPATIBILITY
To maintain backwards compatibility, you need to write a version of the current
syscall in a compat kernel module.  This section describes how that is done.
For the purposes of this section, we assume the current syscall has entry point
.Fn sys_my_syscall
and lives inside
.Pa sys/kern/my_syscall.c .
.Ss Creating the compat current syscall
The compat version of the current syscall has entry point
.Fn compat_XYZ_sys_my_syscall .
By convention, the implementation of this syscall should be located in
.Pa sys/compat/common/my_syscall_XYZ.c .
.Ss Adding it to the compat module
.Pa sys/compat/common/my_syscall_XYZ.c 
should contain an array of
.Ft struct syscall_package
that declares the mapping between syscall number and entry point (TODO should
probably be more specific).
.Pp
Additionally,
.Pa sys/compat/common/my_syscall_XYZ.c 
should contain two functions,
.Fn my_syscall_XYZ_init
and
.Fn my_syscall_XYZ_fini
that can be used to initialize/clean up anything related to this syscall.  At
the minimum they must make calls to
.Fn syscall_establish
and
.Fn syscall_disestablish
respectively, adding and removing the syscalls.  The stubs for these functions
should be located in
.Pa sys/compat/common/compat_mod.h .
.Pp
Finally,
.Pa sys/compat/common/compat_XYZ_mod.c
should be modified to have its
.Fn compat_XYZ_init
and
.Fn compat_XYZ_fini
functions call the one made in the previous paragraph.
.Ss Modifying old compat syscalls
If the current syscall has already been versioned, you may need to modify the
old compat syscalls in
.Pa sys/compat/common
to either use the next syscall or the current compat syscall.  Note that compat
code can be made to depend on compat code for more recent releases.
.Sh USERLAND COMPATIBILITY
With the exception of the libraries described below, making the rest of userland
work will just involve recompiling, and perhaps changing a constant.
.Ss libc
A userland version of any old and current versions of the syscall should be
implemented in terms of the next syscall (TODO should say why) in
.Pa lib/libc/compat/sys
and should contain an appropriate call to
.Fn __warn_references
for old and current versions of the syscall.
